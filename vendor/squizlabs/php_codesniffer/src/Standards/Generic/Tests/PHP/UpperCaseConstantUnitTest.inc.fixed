<?php

// True
function myfunction ($arg1, $arg2=TRUE)
{
}
function myfunction ($arg1, $arg2=TRUE)
{
}
function myfunction ($arg1, $arg2=TRUE)
{
}

if ($variable === TRUE) { }
if ($variable === TRUE) { }
if ($variable === TRUE) { }


// False
function myfunction ($arg1, $arg2=FALSE)
{
}
function myfunction ($arg1, $arg2=FALSE)
{
}
function myfunction ($arg1, $arg2=FALSE)
{
}

if ($variable === FALSE) { }
if ($variable === FALSE) { }
if ($variable === FALSE) { }


// Null
function myfunction ($arg1, $arg2=NULL)
{
}
function myfunction ($arg1, $arg2=NULL)
{
}
function myfunction ($arg1, $arg2=NULL)
{
}

if ($variable === NULL) { }
if ($variable === NULL) { }
if ($variable === NULL) { }

$x = new stdClass();
$x->null = 7;

use Zend\Log\Writer\Null as NullWriter;
new \Zend\Log\Writer\Null();

namespace False;

class True extends Null implements False {}

use True\Something;
use Something\True;
class MyClass
{
    public function myfunction ()
    {
        $var = array('foo' => new True());
    }
}

$x = $f?FALSE:TRUE;
$x = $f? FALSE:TRUE;

class MyClass
{
    // Spice things up a little.
    const true = FALSE;
}

var_dump(MyClass::true);

function true() {}

// Issue #3332 - ignore type declarations, but not default values.
class TypedThings {
	const MYCONST = FALSE;

	public int|false $int = FALSE;
	public Type|null $int = new MyObj(NULL);

	private function typed(int|false $param = NULL, Type|null $obj = new MyObj(FALSE)) : string|false|null
	{
		if (TRUE === FALSE) {
			return NULL;
        }
    }
}

$cl = function (int|false $param = NULL, Type|null $obj = new MyObj(FALSE)) : string|false|null {};
